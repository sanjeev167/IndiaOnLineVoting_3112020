/**
 * 
 */
package com.pon.config.sec;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import javax.servlet.Filter;
import javax.servlet.ServletContext;
import javax.sql.DataSource;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.access.AccessDecisionManager;
import org.springframework.security.access.AccessDecisionVoter;
import org.springframework.security.access.expression.SecurityExpressionHandler;
import org.springframework.security.access.hierarchicalroles.RoleHierarchy;
import org.springframework.security.access.hierarchicalroles.RoleHierarchyImpl;
import org.springframework.security.access.hierarchicalroles.RoleHierarchyUtils;
import org.springframework.security.access.vote.AuthenticatedVoter;
import org.springframework.security.access.vote.RoleVoter;
import org.springframework.security.access.vote.UnanimousBased;
import org.springframework.security.config.annotation.authentication.builders.AuthenticationManagerBuilder;
import org.springframework.security.config.annotation.method.configuration.EnableGlobalMethodSecurity;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.builders.WebSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.config.annotation.web.configuration.WebSecurityConfigurerAdapter;
import org.springframework.security.core.userdetails.User;
import org.springframework.security.core.userdetails.UserDetailsService;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.provisioning.InMemoryUserDetailsManager;
import org.springframework.security.web.AuthenticationEntryPoint;
import org.springframework.security.web.FilterInvocation;
import org.springframework.security.web.access.ExceptionTranslationFilter;
import org.springframework.security.web.access.expression.DefaultWebSecurityExpressionHandler;
import org.springframework.security.web.access.expression.WebExpressionVoter;
import org.springframework.security.web.authentication.LoginUrlAuthenticationEntryPoint;
import org.springframework.security.web.util.matcher.AntPathRequestMatcher;
import org.springframework.social.security.SpringSocialConfigurer;

import com.pon.web.adm.pvt.menu_mgr.service.RoleHierarchyService;
import com.support.custom.exception.CustomRuntimeException;
import com.support.config.filter.AjaxTimeoutRedirectFilter;
import com.pon.web.adm.pub.en.service.CustomAdministrativeUserDetailsServiceImpl;


//import com.pon.config.security.voter.DynamicMethodAccessVoter;
//import com.pon.config.security.voter.MinuteBasedVoter;

/**
 * @author Sanjeev
 *
 */
@Configuration//Requires for method level security
@EnableWebSecurity(debug=false)//Requires for spring security
@EnableGlobalMethodSecurity(prePostEnabled = true, securedEnabled = true,jsr250Enabled = true)//Requires for method level security
public class SpringSecurityConfig extends WebSecurityConfigurerAdapter {
	
	static final Logger log= LoggerFactory.getLogger(SpringSecurityConfig.class);
	

	
	//@Autowired
    private DataSource dataSource;
    
    @Autowired
	CustomAdministrativeUserDetailsServiceImpl DAO_CustomAdministrativeUserDetailsService;
	
  
    
	@Autowired
	private ServletContext servletContext;
	
	@Autowired
	RoleHierarchyService roleHierarchyService;	
	
	/**
	 * This will be used for encoding password
	 **/
	@Bean
	public PasswordEncoder passwordEncoder() {
		return new BCryptPasswordEncoder();
	}
	
	/**
	 * In-Memory user details
	 * **/
	@Bean
	public UserDetailsService InMemory_CustomUserDetailsService() throws Exception {
		InMemoryUserDetailsManager manager = new InMemoryUserDetailsManager();
		manager.createUser(User.withUsername("contactsanjiv@gmail.com").password(passwordEncoder().encode("Super@123"))
				.roles("SUPER_ADMIN").build());
		manager.createUser(User.withUsername("atulraj@gmail.com").password(passwordEncoder().encode("Admin@123"))
				.roles("SECURITY_ADMIN").build());
		manager.createUser(User.withUsername("raulpanday@gmail.com").password(passwordEncoder().encode("Master@123"))
				.roles("MASTER_DEO").build());
		return manager;
	}
	
	/**
	 * JDBC user details
	 * **/	
	public void JDBC_CustomUserDetailsService(AuthenticationManagerBuilder auth) throws Exception {
		
		 auth.jdbcAuthentication().dataSource(dataSource)
		    .usersByUsernameQuery("select username, password, enabled from users where username=?")
	        .authoritiesByUsernameQuery("select username, authority from authorities where username=?").passwordEncoder(passwordEncoder());	
	}
	
	
		
    /**
     * Prepare a role hierarchy 
     * **/
	@Bean
	public RoleHierarchy customRoleHierarchy() throws CustomRuntimeException {		
		RoleHierarchyImpl roleHierarchy = new RoleHierarchyImpl();	
		// roleHierarchy.setHierarchy("ROLE_ADMIN > ROLE_USER");		
		String roles = RoleHierarchyUtils.roleHierarchyFromMap(roleHierarchyService.getRoleHierarchyConfiguredForSecurity());		
		servletContext.setAttribute("RolesInHierarchy",roleHierarchyService.getRoleHierarchyConfiguredForSecurity());		
		log.info("\n\nSanjeev: Role hierarchy = > \n\n" + roles);
		roleHierarchy.setHierarchy(roles);
		//roleHierarchy.setHierarchy("SUPER_ADMIN > SECURITY_ADMIN");
		return roleHierarchy;
	}

	/**
	 * Now prepare a webSecurityExpressionHandler using above role hierarchy
	 * **/
	@Bean
	public SecurityExpressionHandler<FilterInvocation> customRoleHierarchyExpressionHandler() throws CustomRuntimeException {
		DefaultWebSecurityExpressionHandler webSecurityExpressionHandler = new DefaultWebSecurityExpressionHandler();
		webSecurityExpressionHandler.setRoleHierarchy(customRoleHierarchy());
		return webSecurityExpressionHandler;
	}
		
	/**
	 * Here I am creating an authentication manager globally through
	 * AuthenticationManagerBuilder. It will authenticate the incoming user wherever
	 * the security is required.
	 **/
	@Autowired
	public void configureGlobal(AuthenticationManagerBuilder auth) throws Exception {			
		 //auth.userDetailsService(InMemory_CustomUserDetailsService());//Through in memory
		//auth.userDetailsService(JDBC_CustomUserDetailsService());//Through DAO
		auth.userDetailsService(DAO_CustomAdministrativeUserDetailsService);//Through DAO
	}
	
	/**
	 * Here, we prepare web-level security using database
	 * **/
	public void prepareCustomDynamicWebSecurity(HttpSecurity http) throws Exception {		
		Map<String, ArrayList<String>> urlAndAccessRolesMap=urlAndRoleMatcherService().getWebUrlAndRoleMatcherList();        
        Iterator urlAndAccessRolesIterator;
		if (urlAndAccessRolesMap != null) {
			String url_pattern=null;	String roleList[]=null;			
			urlAndAccessRolesIterator = urlAndAccessRolesMap.entrySet().iterator();
			// Iterate through the hashmap
			while (urlAndAccessRolesIterator.hasNext()) {
				@SuppressWarnings("rawtypes")
				Map.Entry mapElement = (Map.Entry) urlAndAccessRolesIterator.next();
				ArrayList<String> roleArr=(ArrayList<String>)mapElement.getValue();
				Object[] roleObjArr=roleArr.toArray();
			    roleList=Arrays.copyOf(roleObjArr, roleObjArr.length,String[].class);
				url_pattern=mapElement.getKey().toString();
				log.info("Ant matcher Url => " + mapElement.getKey() + " : Roles " + mapElement.getValue().toString());				
				http.authorizeRequests().antMatchers(url_pattern+"/*").hasAnyRole(roleList);			
			}
		}		
	}

	/**
	 * We are telling spring to ignore these path from the security
	 **/
	@Override
	public void configure(WebSecurity web) throws Exception {
		web.ignoring().antMatchers("/*.css","/*.js","/favicon.ico");
		web.ignoring().antMatchers("/", "/hm", "/sitemesh/**", "/error/*", "/adm/pub/*", "/resources/**");//Ignore from security
	}

	/**
	 * Now configure actual security here.
	 * @throws Exception 
	
	 * The control comes here just after authentication processing [required or not]
	 * is completed. Here, the access decision manger will examine whether this role
	 * has rights on this url or not. AccessDecissionManger receives an
	 * authentication object from AuthenticationManger.The authentication object has
	 * all the details viz. authentication status and all the assigned roles. They
	 * are loaded by the AuthenticationManager while authenticating the user. If the
	 * AccessDecissionManger finds that any role assigned to this user has access
	 * rights on this url, it allows him to go further into the application. Now,
	 * where is the url list and its associated role access? And who will tell the
	 * access Decision manger that this is the list that you can use it for checking
	 * the access rights?. So, we have to configure these urls pattern and access rights
	 * together somewhere.
	 * 
	 * SpringBoot has defined a process for configuring such urls and access rights together.
	 **/
	
	@Override
	public void configure(HttpSecurity http) throws Exception {		
			
		//http.requiresChannel().anyRequest().requiresSecure();//Redirect to https
	    http.addFilterAfter(ajaxTimeoutRedirectFilter(), ExceptionTranslationFilter.class);		
		http.csrf().disable();		
		
		//####### Url and access rights Configuration Section :Started ########	
		     prepareCustomDynamicWebSecurity(http);	
	   
		http.authorizeRequests()                   
           .anyRequest().authenticated().expressionHandler(customRoleHierarchyExpressionHandler());       
		  // .accessDecisionManager(customAccessDecisionManager());//Implementation of custom access decision manager will impact role hierarchy 
	    // .anyRequest().denyAll()//This will restrict all the request except the authorized role.You can mention some path through antMmatcher  
	  //####### Url and access rights Configuration Section :Ended ########			
		
		
		
	//####### Login Configuration Section : Started ####################
	   http			   
		  .formLogin()
		  .loginPage("/adm/pub/loginUrl")//For opening a custom login page, specify the url for opening this page.
		  .loginProcessingUrl("/doLogin")//An url for submitting login page. It will not be implemented.
		  .defaultSuccessUrl("/adm/pvt/db")//Will transfer the control on this url after successful login.This is post login
				   //.failureForwardUrl("/loginUrl")//Will transfer the control on this url once there is a login failure		  
		  .failureUrl("/adm/pub/loginUrl?error")//Here error is a param that will be checked at the login page for showing error message.
		  .permitAll()//Allowing everyone to access the login page.
		  //####### Login Configuration Section : Ended ####################
		     
		   
		   //####### Logout Configuration Section : Started ############
		   .and()
			   .logout()
				   .logoutUrl("/logout")//Will not be implemented but used as a logout url on the page.		   
				   .logoutSuccessUrl("/adm/pub/loginUrl?logout")//Transferring control at the login page with with a logout flag.logout is a param which will be used 
				                                       //for showing message
				   .clearAuthentication(true)//Will clear all the authentication details
				   .invalidateHttpSession(true)		   
				   .deleteCookies("JSESSIONID")
				   .permitAll()
		   //####### Logout Configuration Section : Ended #############	
				   
				   
		   //####### Exception handling : Started ####################		   
		    .and()
		             .exceptionHandling()
		             .accessDeniedPage("/403") //This will be used access denied exception will be raised.           
		             //Objective: If any unauthenticated users comes with the url /admin/pvt/** , 
		             //it will redirect to the login page through this default entry point.
		             //User is not authenticated and coming with path matching with /pvt/admin/**.
		     	    .defaultAuthenticationEntryPointFor(loginUrlAuthenticationEntryPoint(),new AntPathRequestMatcher("/pvt/**"))
		     	    
		    //####### Exception handling : Started ####################   
		   
		   
		   //####### Remember Me Implementation : Started ###############	
		  /*  .and()
		     	    .rememberMe()
		     	    .rememberMeParameter("remember-me")
		     	    .rememberMeCookieName("pon-remember-me")
		     	    .tokenValiditySeconds(24*60*60)
		     	    .tokenRepository(tokenRepository())
		      */
		   //####### Remember Me Implementation : Ended ##################
		   
		   
		  //####### Session time out configuration : Started #############
		   .and()
			   .sessionManagement()           
		           .invalidSessionUrl("/adm/pub/loginUrl?invalid")//This will be called when wrong session id comes in the cookie        
				   
		           .maximumSessions(1)//Maximum current session has been set as 1
				   .maxSessionsPreventsLogin(false)//It will prevent a user to login concurrently if maximumSessions has reached its limit.
				                                  //While preventing it forcibly expires the session.
				                                  //Don't use true here otherwise it will keep throwing an error and will not allow expiredUrl to be called
				   .expiredUrl("/adm/pub/loginUrl?expired"); //This will be called when the user session is forcibly expired due to more concurrent login 
				                                        // than allowed quota.		
		   //####### Session time out configuration : Ended ###############
		
		
		 
		
		 
		
		  //####### Implement https : Started ####################
		
		
		 //####### Implement https : End ####################
	   
	   
	    //####### Spring Social Config: Started ####################
        // http.apply(new SpringSocialConfigurer()).signupUrl("/signup");
       //####### Spring Social Config: End ####################
	   
	}
	
	
    //This will be used for redirecting to the login page when a user wants to access secured resources
	@Bean
	public AuthenticationEntryPoint loginUrlAuthenticationEntryPoint() {
		//This will take the user at login apge
		return new LoginUrlAuthenticationEntryPoint("/adm/pub/loginUrl?authenticate");
	}


	@Bean
	public Filter ajaxTimeoutRedirectFilter() {
		AjaxTimeoutRedirectFilter atof = new AjaxTimeoutRedirectFilter();
		atof.setCustomSessionExpiredErrorCode(440);
	    return atof;
	}
	
	
	
	
	/*@Bean
	  public PersistentTokenRepository tokenRepository() {
	    JdbcTokenRepositoryImpl jdbcTokenRepositoryImpl=new JdbcTokenRepositoryImpl();
	    jdbcTokenRepositoryImpl.setDataSource(dataSource);
	    return jdbcTokenRepositoryImpl;
	  }
	*/
	
	@Bean
	public AccessDecisionManager customAccessDecisionManager() {
	    List<AccessDecisionVoter<? extends Object>> decisionVoters
	      = Arrays.asList(
	        new WebExpressionVoter(),//Relying on its default implementation
	        new RoleVoter(),//Relying on its default implementation
	        new AuthenticatedVoter()//,//Relying on its default implementation
	        //,new MinuteBasedVoter()//This is a custom voter implementation. We can add any other voter as per our need
	       //, new DynamicMethodAccessVoter()
	        );
	    return new UnanimousBased(decisionVoters); 
	}
	
	@Bean
	UrlAndRoleMatcherService urlAndRoleMatcherService() {
		return new UrlAndRoleMatcherServiceImpl();
	}		
	

}// End of SpringSecurityConfig
